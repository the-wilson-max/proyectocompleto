#Introducción

Este proyecto nace como una oportunidad para poner en práctica conocimientos avanzados en control de versiones con Git y GitHub, desarrollo web full stack y metodologías ágiles. El objetivo no es solo crear una aplicación web funcional, sino también fomentar el trabajo colaborativo, la buena documentación y el uso efectivo de herramientas modernas del ecosistema de desarrollo actual.

El reto consiste en diseñar e implementar una aplicación CRUD (Crear, Leer, Actualizar, Eliminar) desde cero, gestionando un recurso específico como productos, estudiantes, clientes o tareas. Para ello, el equipo hará uso de tecnologías del lado del cliente y del servidor, empleando herramientas como HTML, CSS, JavaScript, y frameworks o librerías como Node.js, Flask, Django o PHP para el backend, junto a bases de datos como MySQL o MongoDB.

Este ejercicio busca no solo entregar un producto funcional, sino también simular un entorno de desarrollo profesional, con integración continua, control de calidad del código y planificación basada en historias de usuario. Una experiencia real para formar desarrolladores listos para enfrentar desafíos del mundo tecnológico actual.

---

# Cuestionario sobre Desarrollo de Software

## 1. ¿Qué es una API REST y cómo se comunica con el frontend?
Una API REST (Representational State Transfer) es un estilo de arquitectura que permite la comunicación entre sistemas de forma sencilla y escalable utilizando el protocolo HTTP. La API expone distintos "endpoints" o rutas, a los que el frontend puede acceder mediante peticiones HTTP como GET, POST, PUT o DELETE. Por ejemplo, el frontend puede hacer una petición GET para obtener datos, o una POST para enviar información al servidor. La comunicación suele realizarse en formato JSON, lo que facilita la interoperabilidad entre diferentes lenguajes y plataformas.

## 2. ¿Qué diferencias hay entre una base de datos relacional y una no relacional?
Las bases de datos relacionales (como MySQL, PostgreSQL) almacenan datos en tablas con filas y columnas, utilizando un lenguaje estructurado (SQL) para realizar consultas. Son ideales cuando los datos tienen relaciones claras y estructuras fijas. En cambio, las bases de datos no relacionales (como MongoDB, Cassandra) usan modelos flexibles como documentos, grafos o pares clave-valor. Estas permiten mayor escalabilidad horizontal y adaptabilidad, siendo útiles para datos no estructurados o con esquemas cambiantes.

## 3. ¿Qué beneficios tiene trabajar con pull requests en lugar de hacer push directamente?
Trabajar con pull requests fomenta la colaboración y el control de calidad del código. Permite que otros miembros del equipo revisen los cambios antes de integrarlos al repositorio principal, lo que ayuda a detectar errores, mejorar la legibilidad del código y mantener la coherencia en el proyecto. Además, facilita la discusión sobre nuevas funcionalidades y promueve buenas prácticas de desarrollo como el trabajo en ramas aisladas.

## 4. ¿Qué son las historias de usuario y cómo ayudan en la planificación de un proyecto?
Las historias de usuario son descripciones breves y simples de funcionalidades vistas desde la perspectiva del usuario final. Siguen una estructura común: "Como [tipo de usuario], quiero [funcionalidad] para [beneficio esperado]". Estas historias permiten descomponer los requerimientos del proyecto en tareas concretas y comprensibles, facilitando la planificación iterativa, la estimación de tiempos y la asignación de responsabilidades dentro del equipo.

## 5. ¿Qué herramientas complementarias existen para CI/CD en proyectos colaborativos?
Existen numerosas herramientas que facilitan la integración continua (CI) y el despliegue continuo (CD) en proyectos colaborativos. Algunas de las más populares incluyen Jenkins, GitHub Actions, GitLab CI/CD, Travis CI y CircleCI. Estas herramientas automatizan procesos como pruebas, compilación y despliegue de código, reduciendo errores humanos y acelerando la entrega de software. También permiten definir flujos de trabajo personalizados y ejecutar acciones en base a eventos del repositorio, como commits o pull requests.
